// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain
#include "GPU_WFC_Utils.cginc"

uniform int nb_patterns;
uniform int width, height;
uniform bool is_periodic;

/*
Actual wave result
wave(node, pattern)
*/
RWStructuredBuffer<bool> wave_data;
#define wave(node, pattern) wave_data[node * nb_patterns + pattern]


struct Weighting
{
    float weight_d;
    float log_weight_d;
};

//TODO: these textures should be doubles. Would need packing into separate channels.
StructuredBuffer<Weighting> weighting;
#define weight(pattern) weighting[pattern].weight_d
#define log_weight(pattern) weighting[pattern].weight_d

struct Memoisation
{
    float sums_of_weights_d;
    float sums_of_weight_log_weights_d;
    float entropies_d;
    int num_possible_patterns_d;
};
RWStructuredBuffer<Memoisation> memoisation;
#define sum_of_weights(node) memoisation[node].sums_of_weights_d
#define sums_of_weight_log_weights(node) memoisation[node].sums_of_weight_log_weights_d
#define entropies(node) memoisation[node].entropies_d
#define num_possible_patterns(node) memoisation[node].num_possible_patterns_d


/*
Which patterns can be placed in which direction of the current node
propagator[uint3(pattern, otherPattern, direction)]
*/
uniform Texture3D<bool> propagator;

struct Compatible
{
    int compatibleDir[4];
};

/*
How many patterns in specific direction of cell are compatible.
*/
RWStructuredBuffer<Compatible> compatible_data;
#define compatible(node, pattern, direction) compatible_data[node * nb_patterns + pattern].compatibleDir[direction]

struct Collapse
{
    bool is_collapsed;
    bool needs_collapse;
};

/* Neighbours of cells that changed. */
uniform StructuredBuffer<Collapse> in_collapse;
#define in_is_collapsed(node) in_collapse[node].is_collapsed
#define in_needs_collapse(node) in_collapse[node].needs_collapse

RWStructuredBuffer<Collapse> out_collapse;
#define out_is_collapsed(node) out_collapse[node].is_collapsed
#define out_needs_collapse(node) out_collapse[node].needs_collapse

/*
Which pattern changed.
input_pattern_change[]
*/
uniform StructuredBuffer<bool> in_pattern_collapsed_data;
#define in_pattern_collapsed(node, pattern) in_pattern_collapsed_data[node * nb_patterns + pattern]

RWStructuredBuffer<bool> out_pattern_collapsed_data;
#define out_pattern_collapsed(node, pattern) out_pattern_collapsed_data[node * nb_patterns + pattern]

RWStructuredBuffer<bool> result;
#define is_possible result[0]
#define open_nodes result[1]

 /* Removes pattern from cell and marks the surrounding cells for update. */
inline void Ban(uint node, uint2 nodeCoord, int pattern)
{
    if (!wave(node, pattern)) return;
    
    wave(node, pattern) = false;
    out_pattern_collapsed(node, pattern) = true;

    num_possible_patterns(node) -= 1;
    sum_of_weights(node) -= weight(pattern);
    sums_of_weight_log_weights(node) -= log_weight(pattern);

    const float sum = sum_of_weights(node);
    entropies(node) = log(sum) - sums_of_weight_log_weights(node) / sum;
    if (num_possible_patterns(node) <= 0)
    {
        is_possible = false;
    }
    
    /* Mark the neighbouring nodes for collapse and update info */
    out_is_collapsed(node) = true;
    for (int direction = 0; direction < 4; direction++)
    {
        /* Generate neighbour coordinate */
        int x2 = nodeCoord.x + directions_x[direction];
        int y2 = nodeCoord.y + directions_y[direction];

        if (is_periodic)
        {
            x2 = ((uint)(x2 + width)) % width;
            y2 = ((uint)(y2 + height)) % height;
        }
        else if (!is_periodic && (x2 < 0
                               || y2 < 0
                               || x2 >= width 
                               || y2 >= height))
        {
            continue;
        }

        const uint node2 = y2 * width + x2;
        out_needs_collapse(node2) = true;
    }
    open_nodes = true;
}

[numthreads(16,16,1)]
void CSMain (uint3 nodeCoord : SV_DispatchThreadID)
{
    /* Return execution if node is outside of working grid. */
    if (any(nodeCoord.xy < 0u) || any(nodeCoord.xy > uint2(width, height))) return;
    
    const int node =  nodeCoord.y * width + nodeCoord.x;
    if (!in_needs_collapse(node)) return;
    for (uint direction = 0; direction < 4; direction++)
    {
        /* Generate neighbour coordinate */
        int x2 = nodeCoord.x + directions_x[direction];
        int y2 = nodeCoord.y + directions_y[direction];

        if (is_periodic)
        {
            x2 = ((uint)(x2 + width)) % width;
            y2 = ((uint)(y2 + height)) % height;
        }
        else if (!is_periodic && (x2 < 0
                               || y2 < 0
                               || x2 >= width 
                               || y2 >= height))
        {
            continue;
        }

        const int node2 = y2 * width + x2;
        if (!in_is_collapsed(node2)) continue;
        
        /* Update compatibility with all removed patterns from the neighbouring node. */
        for (int removed_pattern = 0; removed_pattern < nb_patterns; removed_pattern++)
        {
            /* Check if the pattern was removed from the neighbouring node. */
            if (in_pattern_collapsed(node2, removed_pattern))
            {
                /* Go through all compatible patterns of this cell and decrease them accordingly. */
                for (int compatiblePattern = 0; compatiblePattern < nb_patterns; compatiblePattern++)
                {
                    if (propagator[uint3(removed_pattern, compatiblePattern, opposite_direction[direction])])
                    {
                        /* Ban pattern from node when it comes incompatible with other node. */
                        if (--compatible(node, compatiblePattern, direction) == 0)
                        {
                            Ban(node, nodeCoord.xy, compatiblePattern);
                        }
                    }
                }
            }
        }
    }
}