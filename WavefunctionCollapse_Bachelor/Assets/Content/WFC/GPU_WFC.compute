// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain
#include "GPU_WFC_Utils.cginc"

uniform int nb_patterns;
uniform int width, height;
uniform bool is_periodic;

//Using ints instead of bools because Unity doesnt support bools natively and the data isnt copied properly.

/*
Actual wave result
wave(node, pattern)
*/
RWStructuredBuffer<uint> wave_data;
#define WAVE(node, pattern) wave_data[node * nb_patterns + pattern]


struct Weighting
{
    float weight_d;
    float log_weight_d;
};

//TODO: these textures should be doubles. Would need packing into separate channels.
StructuredBuffer<Weighting> weighting;
#define WEIGHT(pattern) weighting[pattern].weight_d
#define LOG_WEIGHT(pattern) weighting[pattern].weight_d

struct Memoisation
{
    float sums_of_weights_d;
    float sums_of_weight_log_weights_d;
    float entropies_d;
    int num_possible_patterns_d;
};
RWStructuredBuffer<Memoisation> memoisation;
#define SUM_OF_WEIGHTS(node) memoisation[node].sums_of_weights_d
#define SUMS_OF_WEIGHT_LOG_WEIGHTS(node) memoisation[node].sums_of_weight_log_weights_d
#define ENTROPIES(node) memoisation[node].entropies_d
#define NUM_POSSIBLE_PATTERNS(node) memoisation[node].num_possible_patterns_d


struct Propagator
{
    uint propagatorDir[4];
};
/*
Which patterns can be placed in which direction of the current node
propagator[uint3(pattern, otherPattern, direction)]
*/
uniform StructuredBuffer<Propagator> propagator;
#define PROPAGATOR(pattern, otherPattern, direction) propagator[pattern * nb_patterns + otherPattern].propagatorDir[direction]


struct Collapse
{
    uint is_collapsed;
    uint needs_collapse;
};

/* Neighbours of cells that changed. */
uniform StructuredBuffer<Collapse> in_collapse;
#define IN_IS_COLLAPSED(node) in_collapse[node].is_collapsed
#define IN_NEEDS_COLLAPSE(node) in_collapse[node].needs_collapse

RWStructuredBuffer<Collapse> out_collapse;
#define OUT_IS_COLLAPSED(node) out_collapse[node].is_collapsed
#define OUT_NEEDS_COLLAPSE(node) out_collapse[node].needs_collapse

struct Result
{
    uint is_possible;
    uint open_nodes;
};
RWStructuredBuffer<Result> result;
#define IS_POSSIBLE result[0].is_possible
#define OPEN_NODES result[0].open_nodes

#define TRUE 1u
#define FALSE 0u

 /* Removes pattern from cell and marks the surrounding cells for update. */
void Ban(uint node, uint2 nodeCoord, int pattern)
{
    OPEN_NODES = TRUE;
    WAVE(node, pattern) = FALSE;
    
    NUM_POSSIBLE_PATTERNS(node) -= 1;
    SUM_OF_WEIGHTS(node) -= WEIGHT(pattern);
    SUMS_OF_WEIGHT_LOG_WEIGHTS(node) -= LOG_WEIGHT(pattern);

    const float sum = SUM_OF_WEIGHTS(node);
    ENTROPIES(node) = log(sum) - SUMS_OF_WEIGHT_LOG_WEIGHTS(node) / sum;
    if (NUM_POSSIBLE_PATTERNS(node) <= 0)
    {
        IS_POSSIBLE = FALSE;
    }
    
    /* Mark the neighbouring nodes for collapse and update info */
    OUT_IS_COLLAPSED(node) = TRUE;
    for (int direction = 0; direction < 4; direction++)
    {
        /* Generate neighbour coordinate */
        int x2 = nodeCoord.x + directions_x[direction];
        int y2 = nodeCoord.y + directions_y[direction];

        if (is_periodic)
        {
            x2 = ((uint)(x2 + width)) % width;
            y2 = ((uint)(y2 + height)) % height;
        }
        else if (!is_periodic && (x2 < 0
                               || y2 < 0
                               || x2 >= width 
                               || y2 >= height))
        {
            continue;
        }

        const uint node2 = y2 * width + x2;
        OUT_NEEDS_COLLAPSE(node2) = TRUE;
    }
}

[numthreads(16,16,1)]
void CSMain (uint3 nodeCoord : SV_DispatchThreadID)
{
    /* Return execution if node is outside of working grid. */
    if (any(nodeCoord.xy < 0u) || any(nodeCoord.xy >= uint2(width, height))) return;
    
    const int node =  nodeCoord.y * width + nodeCoord.x;
    if (IN_NEEDS_COLLAPSE(node) == FALSE) return;
    
    for (uint direction = 0; direction < 4; direction++)
    {
        /* Generate neighbour coordinate */
        int x2 = nodeCoord.x + directions_x[direction];
        int y2 = nodeCoord.y + directions_y[direction];

        if (is_periodic)
        {
            x2 = ((uint)(x2 + width)) % width;
            y2 = ((uint)(y2 + height)) % height;
        }
        else if (!is_periodic && (x2 < 0
                               || y2 < 0
                               || x2 >= width 
                               || y2 >= height))
        {
            continue;
        }

        const int node2 = y2 * width + x2;
        if (IN_IS_COLLAPSED(node2) == FALSE) continue;

        /*
         * Go over all still possible patterns in the current node and check if the are compatible
         * with the still possible patterns of the other node.
         */
        for (int possible_node_pattern = 0; possible_node_pattern < nb_patterns; possible_node_pattern++)
        {
            if (WAVE(node, possible_node_pattern) == TRUE)
            {
                /*
                 * Go over all possible patterns of the other cell and check if any of them are compatible
                 * with the possibleNodePattern
                 */
                bool any_possible = false;
                for (int compatible_pattern = 0; compatible_pattern < nb_patterns; compatible_pattern++)
                {
                   if (WAVE(node2, compatible_pattern) == TRUE)
                   {
                       if (PROPAGATOR(possible_node_pattern, compatible_pattern, direction) == TRUE)
                       {
                           any_possible = true;
                           break;
                       }
                   }
                }
                /* If there were no compatible patterns found Ban the pattern. */
                if (!any_possible)
                {
                    Ban(node, nodeCoord.xy, possible_node_pattern);
                }
            }
        }
    }
}